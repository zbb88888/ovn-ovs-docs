# 逻辑交换机数据路径

## 入口表 0: 准入控制和入口端口安全检查

入口表 0 包含以下逻辑流：

*   优先级 100 的流，用于丢弃带有 VLAN 标记或组播以太网源地址的数据包。

*   对于每个禁用的逻辑端口，添加一个优先级 100 的流，该流匹配所有数据包并应用操作 `REGBIT_PORT_SEC_DROP" = 1; next;"`，以便在下一阶段丢弃数据包。

*   对于每个定义为路由协议重定向目标的逻辑端口（通过在逻辑路由器端口上设置 `routing-protocol-redirect` 选项），设置一个过滤器，禁止以下流量离开此端口：
    *   ARP 回复
    *   IPv6 邻居发现 - 路由器通告
    *   IPv6 邻居发现 - 邻居通告

    由于此端口与逻辑路由器端口共享 IP 和 MAC 地址，我们希望防止重复的回复和通告。这是通过一个优先级 80 的规则实现的，该规则设置 `REGBIT_PORT_SEC_DROP" = 1; next;"`。

*   对于每个具有连接的物理端口（`localnet` 或 `l2gateway`）且也连接到分布式路由器的逻辑交换机，为来自 `localnet` 或 `l2gateway` 端口的 ARP 请求添加过滤规则，允许在网关 chassis 上处理。对于所有源自物理端口的 ARP 请求，优先级 75 的流设置 `REGBIT_EXT_ARP` 寄存器。

*   对于每个（启用的）vtep 逻辑端口，添加一个优先级 70 的流，该流匹配所有数据包并应用操作 `next(pipeline=ingress, table=S_SWITCH_IN_L3_LKUP) = 1;` 以跳过入口管道的大多数阶段并直接进入入口 L2 查找表以确定输出端口。来自 VTEP (RAMP) 交换机的数据包不应受到任何 ACL 检查。出口管道将执行 ACL 检查。

*   对于在 `Logical_Switch_Port` 的 `options:qdisc_queue_id` 列中配置了 qdisc 队列 ID 的每个启用的逻辑端口，添加一个优先级 70 的流，该流匹配所有数据包并应用操作 `set_queue(id); REGBIT_PORT_SEC_DROP" = check_in_port_sec(); next;"`。

*   添加一个优先级 1 的流，该流匹配所有逻辑端口的所有数据包，并应用操作 `REGBIT_PORT_SEC_DROP" = check_in_port_sec(); next;` 以评估端口安全性。操作 `check_in_port_sec` 应用 `Logical_Switch_Port` 表的 `port_security` 列中定义的端口安全规则。

## 入口表 1: 入口端口安全 - 应用

*   对于每个连接到 gw 路由器的 router 类型的逻辑交换机端口 P，一个优先级 120 的流，匹配“再循环” icmp{4,6} 错误“数据包太大”且 `eth.src == D && outport == P && flags.tunnel_rx == 1`（其中 D 是对等逻辑路由器端口 RP 的 mac 地址），交换 inport 和 outport 并应用操作 `next`。

*   对于每个连接到分布式路由器的 router 类型的逻辑交换机端口 P，一个优先级 120 的流，匹配“再循环” icmp{4,6} 错误“数据包太大”且 `eth.dst == D && flags.tunnel_rx == 1`（其中 D 是对等逻辑路由器端口 RP 的 mac 地址），交换 inport 和 outport 并应用操作 `next(pipeline=S_SWITCH_IN_L2_LKUP)`。

*   对于每个逻辑交换机端口 P，一个优先级 110 的流，匹配“再循环” icmp{4,6} 错误“数据包太大”且 `eth.src == D && outport == P && !is_chassis_resident("P") && flags.tunnel_rx == 1`（其中 D 是逻辑交换机端口 mac 地址），交换 inport 和 outport 并应用操作 `next`。

*   此表添加一个优先级 105 的流，匹配“再循环” icmp{4,6} 错误“数据包太大”以丢弃数据包。

*   如果前一阶段的端口安全检查失败（即寄存器位 `REGBIT_PORT_SEC_DROP` 设置为 1），此表将丢弃数据包。

入口表 1 包含以下逻辑流：

*   一个优先级 50 的回退流，如果寄存器位 `REGBIT_PORT_SEC_DROP` 设置为 1，则丢弃数据包。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

*   优先级 75：仅在网关 chassis 和具有分布式 NAT 条目的 chassis 上允许 `REGBIT_EXT_ARP` 数据包。
    优先级 70：在非网关 chassis 上丢弃 `REGBIT_EXT_ARP` 数据包（补充优先级 75 的流）。

## 入口表 2: 镜像

覆盖远程镜像表包含以下逻辑流：

*   对于每个附加了镜像的逻辑交换机端口，添加一个优先级为 100 的逻辑流。此流匹配所有进入附加端口的数据包，克隆它们，并将克隆的数据包转发到镜像目标端口。

*   添加一个优先级 0 的流，匹配所有数据包并应用操作 `next;`。

*   为镜像表中附加到逻辑交换机端口的每个镜像规则添加一个逻辑流，匹配所有符合规则的传入数据包，克隆数据包并将克隆的数据包发送到镜像目标端口。

## 入口表 3: 查找 MAC 地址学习表

此表查找逻辑交换机数据路径的 MAC 学习表，以检查 port-mac 对是否存在。为端口安全性被禁用且设置了“unknown”地址的逻辑交换机 VIF 端口以及设置了 `localnet_learn_fdb` 选项的 localnet 端口学习 MAC。localnet 端口条目不会覆盖 VIF 端口条目。类型为 switch 的逻辑交换机端口具有隐式的“unknown”地址，因此它们也有资格进行 MAC 学习。

*   对于每个端口安全性被禁用且设置了“unknown”地址的 VIF 逻辑端口 p，添加以下流。
    *   优先级 100 的流，匹配 `inport == p`，操作为 `reg0[11] = lookup_fdb(inport, eth.src); next;`

*   对于每个这样的 localnet 逻辑端口 p，添加以下流。
    *   优先级 100 的流，匹配 `inport == p`，操作为 `flags.localnet = 1; reg0[11] = lookup_fdb(inport, eth.src); next;`

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 4: 学习“unknown”端口的 MAC

此表学习在端口安全性被禁用且设置了“unknown”地址的 VIF 或“switch”逻辑端口上看到的 MAC 地址（注意：“switch”端口具有隐式的“unknown”地址），以及如果 `lookup_fdb` 操作在前一个表中返回 false，则在设置了 `localnet_learn_fdb` 选项的 localnet 端口上学习 MAC 地址。对于 localnet 端口（`flags.localnet = 1`），如果找到 (port, mac) 或如果找到类型为 vif 的端口的 mac，则 `lookup_fdb` 返回 true。

*   对于每个端口安全性被禁用且设置了“unknown”地址的 VIF 逻辑端口 p 和 localnet 端口，添加以下流。
    *   优先级 100 的流，匹配 `inport == p && reg0[11] == 0`，操作为 `put_fdb(inport, eth.src); next;`，它将 port-mac 存储在逻辑交换机数据路径的 mac 学习表中，并将数据包推进到下一个表。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 5: from-lport 预 ACL (Pre-ACLs)

此表为入口表 ACL 中可能的有状态 ACL 处理准备流。它包含一个优先级 0 的流，只是将流量移动到下一个表。如果在逻辑数据路径中使用了有状态 ACL，则添加一个优先级 100 的流，为表 Pre-stateful 设置提示（`reg0[0] = 1; next;`），以便在最终前进到入口表 ACL 之前将 IP 数据包发送到连接跟踪器。如果特殊端口（如 route 端口或 localnet 端口）不能使用 `ct()`，则添加一个优先级 110 的流以跳过有状态 ACL。如果在 `Logical_Switch_Port` 表的 `options:enable_router_port_acl` 列中将选项 `enable_router_port_acl` 设置为 true，则不会为路由器端口添加此优先级 110 的流。组播、IPv6 邻居发现和 MLD 流量也跳过有状态 ACL。对于“allow-stateless” ACL，添加一个流以在存在有状态 ACL 或 LB 规则时绕过设置连接跟踪器处理的提示；为匹配无状态 ACL 流的流量设置 `REGBIT_ACL_STATELESS`。

此表还有一个优先级 110 的流，匹配 `eth.dst == E`，适用于所有逻辑交换机数据路径，将流量移动到下一个表。其中 E 是 `NB_Global` 表 `options:svc_monitor_mac` 列中定义的服务监视器 mac。

## 入口表 6: Pre-LB

此表为入口表 LB 和 Stateful 中可能的有状态负载均衡处理准备流。它包含一个优先级 0 的流，只是将流量移动到下一个表。此外，它包含两个优先级 110 的流，将组播、IPv6 邻居发现和 MLD 流量移动到下一个表。它还包含两个优先级 110 的流，将无状态流量（即设置了 `REGBIT_ACL_STATELESS` 的流量）移动到下一个表。如果在 OVN_Northbound 数据库中为逻辑交换机数据路径配置了具有虚拟 IP 地址（和端口）的负载均衡规则，则添加一个优先级 100 的流，匹配 ip 以匹配 IP 数据包，并设置操作 `reg0[2] = 1; next;` 作为表 Pre-stateful 的提示，以便在最终前进到入口表 Stateful 之前将 IP 数据包发送到连接跟踪器进行数据包重组（并可能对已建立的负载均衡流量进行 DNAT）。如果启用了 `controller_event` 并在 OVN_Northbound 中添加了具有空后端的负载均衡规则，则添加一个 130 流，以便每当 chassis 收到该特定 VIP 的数据包时触发 `ovn-controller` 事件。如果先前已创建 `event-elb` 计量器，它将关联到 `empty_lb` 逻辑流。

在 OVN 20.09 之前，我们仅在 IP 目标匹配负载均衡器 VIP 时才设置 `reg0[0] = 1`。但是，在逻辑交换机没有任何具有 `allow-related` 操作的 ACL 的情况下，这几乎没有问题。为了理解这个问题，让我们以 TCP 负载均衡器为例 - `10.0.0.10:80=10.0.0.3:80`。如果具有 IP `10.0.0.5` 的逻辑端口 `p1` 与 VIP `10.0.0.10` 打开 TCP 连接，则 `p1` 的入口管道中的数据包将发送到 `p1` 的 conntrack 区域 id，并且数据包将负载均衡到后端 `10.0.0.3`。对于来自后端 lport 的回复数据包，它不会发送到后端 lport 的区域 id 的 conntrack。只要数据包有效，这就可以。假设后端 lport 发送无效的 TCP 数据包（如不正确的序列号），数据包将在不将数据包 unDNAT 到 VIP `10.0.0.10` 的情况下传递到 lport `p1`。这会导致 lport `p1` 的 VIF 重置连接。

我们不能通过在出口管道中添加逻辑流来丢弃 `ct.inv` 数据包来解决此问题，因为它将丢弃所有其他未发往负载均衡器的连接。为了解决此问题，如果配置了负载均衡器，我们将所有数据包发送到入口管道中的 conntrack。我们现在可以添加一个 lflow 来丢弃 `ct.inv` 数据包。

此表还有优先级 120 的流，如果交换机是启用了组播侦听的互连交换机，则将所有 IGMP/MLD 数据包发送到 `ovn-controller`。

此表还有一个优先级 110 的流，匹配 `eth.dst == E`，适用于所有逻辑交换机数据路径，将流量移动到下一个表。其中 E 是 `NB_Global` 表 `options:svc_monitor_mac` 列中定义的服务监视器 mac。

此表还有一个优先级 110 的流，匹配 `inport == I`，适用于所有逻辑交换机数据路径，将流量移动到下一个表。其中 I 是逻辑路由器端口的对等体。添加此流是为了跳过从逻辑路由器数据路径进入逻辑交换机数据路径的数据包的连接跟踪。

## 入口表 7: Pre-stateful

此表为下一个表中的所有可能的有状态处理准备流。它包含一个优先级 0 的流，只是将流量移动到下一个表。

*   优先级 120 的流，使用 `ct_lb_mark;` 作为操作将数据包发送到连接跟踪器，以便发往负载均衡器 VIP 的已建立流量得到 DNAT。这些流匹配每个 VIP 的 IP 和端口。对于 IPv4 流量，流还将原始目标 IP 和传输端口加载到寄存器 `reg1` 和 `reg2` 中。对于 IPv6 流量，流还将原始目标 IP 和传输端口加载到寄存器 `xxreg1` 和 `reg2` 中。

*   优先级 110 的流，根据前一个表提供的提示（匹配 `reg0[2] == 1`），使用 `ct_lb_mark;` 操作将不匹配上述流的数据包发送到连接跟踪器。

*   当启用 `enable-stateless-acl-with-lb` 时添加优先级 105，并将所有指向 VIP 但不匹配上述流的数据包发送到连接跟踪器。

*   优先级 100 的流，根据前一个表提供的提示（匹配 `reg0[0] == 1`），使用 `ct_next;` 操作将数据包发送到连接跟踪器。

## 入口表 8: from-lport ACL 提示

此表包含设置提示（`reg0` 位）的逻辑流，如果在下一阶段（ACL 处理表）中配置了有状态 ACL 或负载均衡器，则使用这些提示。可以为同一个数据包设置多个提示。可能的提示是：

*   `reg0[7]`: 数据包可能匹配 `allow-related` ACL，并且可能必须将连接提交到 conntrack。

*   `reg0[8]`: 数据包可能匹配 `allow-related` ACL，但无需将连接提交到 conntrack，因为它已经存在。

*   `reg0[9]`: 数据包可能匹配 `drop/reject`。

*   `reg0[10]`: 数据包可能匹配 `drop/reject` ACL，但该连接先前已被允许，因此可能必须使用 `ct_label=1/1` 再次提交。

该表包含以下流：

*   如果逻辑交换机未配置 ACL，则为优先级 65535 的流以前进到下一个表，否则为优先级 0 的流以前进到下一个表。

*   优先级 7 的流，匹配发起新会话的数据包。此流设置 `reg0[7]` 和 `reg0[9]`，然后前进到下一个表。

*   优先级 6 的流，匹配处于已标记为阻塞的现有会话的请求方向的数据包。此流设置 `reg0[7]` 和 `reg0[9]`，然后前进到下一个表。

*   优先级 5 的流，匹配未跟踪的数据包。此流设置 `reg0[8]` 和 `reg0[9]`，然后前进到下一个表。

*   优先级 4 的流，匹配处于未标记为阻塞的现有会话的请求方向的数据包。此流设置 `reg0[8]` 和 `reg0[10]`，然后前进到下一个表。

*   优先级 3 的流，匹配不属于已建立会话的数据包。此流设置 `reg0[9]`，然后前进到下一个表。

*   优先级 2 的流，匹配属于已标记为阻塞的已建立会话的数据包。此流设置 `reg0[9]`，然后前进到下一个表。

*   优先级 1 的流，匹配属于未标记为阻塞的已建立会话的数据包。此流设置 `reg0[10]`，然后前进到下一个表。

## 入口表 9: LB 前的 from-lport ACL 评估

此表中的逻辑流密切复制了 OVN_Northbound 数据库中 ACL 表中 `from-lport` 方向且 `apply-after-lb` 选项未设置或设置为 false 的流。ACL 表中的优先级值范围有限，并增加了 1000，以便为更高和更低优先级的 OVN 默认流留出空间。

*   此表负责评估 ACL，并设置寄存器位以指示 ACL 决定允许、丢弃还是拒绝流量。允许位是 `reg8[16]`。丢弃位是 `reg8[17]`。此表中的所有流都将数据包推进到下一个表，在该表中评估之前的位以确定如何处理数据包。此表中任何打算让数据包通过的流都将 `reg8[16]` 设置为 1，即使没有匹配到具有允许类型操作的 ACL。这让下一个表知道允许流量通过。在接下来的段落中，这些位将被称为“允许”、“丢弃”和“拒绝”位。

*   如果在 ACL 上配置了 `tier` 列，则 OVN 还将当前层计数器与配置的 ACL 层进行匹配。OVN 在 `reg8[30..31]` 中保持当前层的计数。

*   `allow` ACL 转换为将允许位设置为 1 并将数据包推进到下一个表的逻辑流。如果此数据路径上有任何有状态 ACL，则 `allow` ACL 将允许位设置为 1，并另外执行 `ct_commit;`（这作为未来表将连接提交到 conntrack 的提示）。如果 ACL 具有标签，则 `reg3` 加载标签值，并且 `reg0[13]` 位设置为 1（这作为下一个表将标签提交到 conntrack 的提示）。

*   `allow-related` ACL 转换为设置允许位的逻辑流，并且对于新连接具有 `ct_commit { ct_label=0/1; }; next;` 操作，对于现有连接具有 `reg0[1] = 1; next;` 操作。如果 ACL 具有标签，则 `reg3` 加载标签值，并且 `reg0[13]` 位设置为 1（这作为下一个表将标签提交到 conntrack 的提示）。

*   对于 `allow` 和 `allow-related` ACL，如果 ACL 的 `network_function_group` 列设置为 `Network_Function_Group` 表中实体之一的 id，则会设置一组额外的寄存器。该 id 是 `Network_Function_Group` 实体的内部生成的唯一标识符。流设置 `reg8[21] = 1`（指示需要数据包重定向），`reg8[22] = 1`（指示这是请求数据包）和 `reg0[22..29] = id`。这些寄存器稍后在网络功能表中使用。

*   `allow-stateless` ACL 转换为设置允许位并前进到下一个表的逻辑流。

*   `reject` ACL 转换为设置拒绝位并前进到下一个表的逻辑流。

*   `pass` ACL 转换为不设置允许、丢弃或拒绝位并前进到下一个表的逻辑流。

*   其他 ACL 为新连接或未跟踪连接设置丢弃位并前进到下一个表。对于已知连接，它们设置丢弃位，并运行 `ct_commit { ct_label=1/1; };` 操作。设置 `ct_label` 将连接标记为先前已允许，但由于策略更改而不应再允许的连接。

此表包含一个优先级 65535 的流，如果逻辑交换机没有配置 ACL，则设置允许位并前进到下一个表，否则添加一个优先级 0 的流以前进到下一个表。此流不设置允许位，以便下一个表可以根据 `NB_Global` 表的 `options:default_acl_drop` 列的值决定是允许还是丢弃数据包。

添加了一个优先级 65532 的流，无论定义了其他 ACL 如何，都为 IPv6 邻居请求、邻居发现、路由器请求、路由器通告和 MLD 数据包设置允许位。

如果逻辑数据路径配置了有状态 ACL 或带有 VIP 的负载均衡器，还将添加以下流：

*   如果 `NB_Global` 的 `options:default_acl_drop` 列为 false 或未设置，则添加一个优先级 1 的流，设置提示以将不属于已建立会话的 IP 流量提交到连接跟踪器（操作为 `reg0[1] = 1; next;`）。这是默认允许策略所需要的，因为虽然发起者的方向可能没有任何有状态规则，但服务器的方向可能有，那么它的返回流量将是未知的并被标记为无效。

*   一个优先级 1 的流，设置允许位并设置提示以将 IP 流量提交到连接跟踪器（操作为 `reg0[1] = 1; next;`）。这是默认允许策略所需要的，因为虽然发起者的方向可能没有任何有状态规则，但服务器的方向可能有，那么它的返回流量将是未知的并被标记为无效。

*   一个优先级 65532 的流，只要已提交的流没有设置 `ct_mark.blocked`，就为已提交到连接跟踪器的连接（即已建立的流）的回复方向的任何流量设置允许位。我们在这里只处理回复方向的流量，因为我们希望所有请求方向的数据包仍然通过基于 ACL 实现当前定义策略的流。如果连接不再被策略允许，`ct_mark.blocked` 将被设置，并且回复方向的数据包也将不再被允许。此流还清除寄存器位 `reg0[9]` 和 `reg0[10]` 并设置寄存器位 `reg0[17]`。如果启用了 ACL 日志记录和相关数据包的日志记录，则将安装一个伴随的优先级 65533 的流，该流完成相同的事情但也记录流量。

*   允许响应和相关流量的优先级 65532 流也设置 `reg8[21] = ct_label.nf_group`，这在网络功能表中进行检查。

*   一个优先级 65532 的流，只要已提交的流没有设置 `ct_mark.blocked`，就为被认为与连接跟踪器中已提交流相关的任何流量（例如，来自非监听 UDP 端口的 ICMP 端口不可达）设置允许位。此流还对相关流量应用 NAT，以便 ICMP 标头和内部数据包具有正确的地址。如果启用了 ACL 日志记录和相关数据包的日志记录，则将安装一个伴随的优先级 65533 的流，该流完成相同的事情但也记录流量。

*   一个优先级 65532 的流，为连接跟踪器标记为无效的所有流量设置丢弃位。

*   一个优先级 65532 的流，为回复方向上设置了 `ct_mark.blocked` 的所有流量设置丢弃位，这意味着由于策略更改，连接不应再被允许。此处跳过请求方向的数据包，以允许新创建的 ACL 重新允许此连接。

如果逻辑数据路径配置了任何 ACL 或带有 VIP 的负载均衡器，还将添加以下流：

*   为每个逻辑交换机数据路径添加一个优先级 34000 的逻辑流，匹配 `eth.dst = E`，以允许发往 `ovn-controller` 的服务监视器回复数据包设置允许位，其中 E 是 `NB_Global` 表的 `options:svc_monitor_mac` 列中定义的服务监视器 mac。

## 入口表 10: from-lport ACL 采样

此表中的逻辑流对启用了采样的 `from-lport` ACL 匹配的流量进行采样。

*   如果没有 ACL 启用采样，则安装一个优先级 0 的流，匹配所有内容并前进到下一个表。

*   对于配置了 `sample_new` 的每个 ACL，安装一个优先级 1100 的流，匹配保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。

*   对于配置了 `sample_est` 的每个 ACL，安装一个优先级 1200 的流，匹配原始方向上已建立流量的保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。

*   对于配置了 `sample_est` 的每个 ACL，安装一个优先级 1200 的流，匹配回复方向上已建立流量的保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。注意：此流安装在相反的管道中（对于在出口方向应用的 ACL 安装在入口管道中，对于在入口方向应用的 ACL 安装在出口管道中）。

## 入口表 11: from-lport ACL 操作

此表中的逻辑流根据前一个表中可能已设置的允许、丢弃和拒绝位的值决定如何继续。

*   如果未配置 ACL，则安装一个优先级 0 的流，匹配所有内容并前进到下一个表。

*   安装一个优先级 1000 的流，如果设置了允许位，则将数据包推进到下一个表。

*   安装一个优先级 1000 的流，如果设置了丢弃位，则运行 `drop;` 操作。

*   安装一个优先级 1000 的流，如果是 TCP 连接则运行 `tcp_reset { output <-> inport; next(pipeline=egress,table=5);}` 操作，如果是 UDP 连接则运行 `icmp4/icmp6` 操作，如果是 SCTP 关联则运行 `sctp_abort {output <-> inport; next(pipeline=egress,table=5);}` 操作。

*   如果有任何 ACL 配置了层，则安装三个优先级 500 的流。如果当前层计数器为 0、1 或 2，则当前层计数器加一，并将数据包送回上一个表进行重新评估。

## 入口表 12: from-lport QoS

此表中的逻辑流密切复制了 OVN_Northbound 数据库中 `from-lport` 方向设置了 action 或 bandwidth 列的 QoS 表中的流。

*   对于逻辑交换机中启用了 DSCP 标记、数据包标记或计量的每个 `qos_rules` 条目，将在 QoS 表中提到的优先级添加一个流。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 13: 连接跟踪字段提取

此表提取新连接的连接跟踪字段，以供后续负载均衡阶段使用。

*   一个优先级 100 的流匹配 `ct.new && ip` 并使用操作 `reg1[16..23] = ct_proto(); reg1[0..15] = ct_tp_dst(); next;` 将连接跟踪协议和目标端口信息提取到寄存器 `reg1[16..23]` (协议) 和 `reg1[0..15]` (目标端口) 中。

*   一个优先级 0 的流匹配所有数据包并前进到下一个表。

## 入口表 14: 负载均衡亲和性检查

负载均衡亲和性检查表包含以下逻辑流：

*   对于 OVN_Northbound 数据库中交换机的所有已配置负载均衡规则，如果 `options` 列中指定了正的亲和性超时，且包括协议 P 的 L4 端口 PORT 和 IP 地址 VIP，则添加一个优先级 100 的流。对于 IPv4 VIP，流匹配 `ct.new && ip && ip4.dst == VIP && reg1[16..23] == PROTO_NUM && reg1[0..15] == PORT`。对于 IPv6 VIP，流匹配 `ct.new && ip && ip6.dst == VIP && reg1[16..23] == PROTO_NUM && reg1[0..15] == PORT`。流的操作是 `reg9[6] = chk_lb_aff(); next;`。

*   添加一个优先级 0 的流，匹配所有数据包并应用操作 `next;`。

## 入口表 15: LB

*   对于 OVN_Northbound 数据库中交换机的所有已配置负载均衡规则，如果 `options` 列中指定了正的亲和性超时，且包括协议 P 的 L4 端口 PORT 和 IP 地址 VIP，则添加一个优先级 150 的流。对于 IPv4 VIP，流匹配 `reg9[6] == 1 && ct.new && ip && ip4.dst == VIP && P.dst == PORT`。对于 IPv6 VIP，流匹配 `reg9[6] == 1 && ct.new && ip && ip6.dst == VIP && P && P.dst == PORT`。流的操作是 `ct_lb_mark(args)`，其中 `args` 包含逗号分隔的 IP 地址（和可选端口号）以进行负载均衡。`args` 的 IP 地址的地址族与 VIP 的地址族相同。

*   对于 OVN_Northbound 数据库中交换机的所有已配置负载均衡规则，如果包括协议 P 的 L4 端口 PORT 和 IP 地址 VIP，则添加一个优先级 120 的流。对于 IPv4 VIP，流匹配 `ct.new && ip && ip4.dst == VIP && reg1[16..23] == PROTO_NUM && reg1[0..15] == PORT`。对于 IPv6 VIP，流匹配 `ct.new && ip && ip6.dst == VIP && reg1[16..23] == PROTO_NUM && reg1[0..15] == PORT`。流的操作是 `ct_lb_mark(args)`，其中 `args` 包含逗号分隔的 IP 地址（和可选端口号）以进行负载均衡。`args` 的 IP 地址的地址族与 VIP 的地址族相同。如果启用了健康检查，则 `args` 将仅包含其在 OVN_Southbound db 中的服务监视器状态条目为在线或空的端点。对于 IPv4 流量，流还将原始目标 IP 和传输端口加载到寄存器 `reg1` 和 `reg2` 中。对于 IPv6 流量，流还将原始目标 IP 和传输端口加载到寄存器 `xxreg1` 和 `reg2` 中。即使负载均衡器附加到连接到当前逻辑交换机的逻辑路由器，并且选项中的 `install_ls_lb_from_router` 变量设置为 true，也会创建上述流。

*   对于 OVN_Northbound 数据库中交换机的所有已配置负载均衡规则，如果仅包含要匹配的 IP 地址 VIP，OVN 添加一个优先级 110 的流。对于 IPv4 VIP，流匹配 `ct.new && ip && ip4.dst == VIP`。对于 IPv6 VIP，流匹配 `ct.new && ip && ip6.dst == VIP`。此流上的操作是 `ct_lb_mark(args)`，其中 `args` 包含与 VIP 相同地址族的逗号分隔的 IP 地址。对于 IPv4 流量，流还将原始目标 IP 和传输端口加载到寄存器 `reg1` 和 `reg2` 中。对于 IPv6 流量，流还将原始目标 IP 和传输端口加载到寄存器 `xxreg1` 和 `reg2` 中。即使负载均衡器附加到连接到当前逻辑交换机的逻辑路由器，并且选项中的 `install_ls_lb_from_router` 变量设置为 true，也会创建上述流。

*   如果使用 `--reject` 选项创建负载均衡器并且它没有活动后端，则每当收到此负载均衡器的传入数据包时，将发送 TCP 重置段（对于 tcp）或 ICMP 端口不可达数据包（对于所有其他类型的流量）。请注意，使用 `--reject` 选项将禁用此负载均衡器的 `empty_lb` SB 控制器事件。

## 入口表 16: 负载均衡亲和性学习

负载均衡亲和性学习表包含以下逻辑流：

*   对于 OVN_Northbound 数据库中交换机的所有已配置负载均衡规则，如果 `options` 列中指定了正的亲和性超时 T，且包括协议 P 的 L4 端口 PORT 和 IP 地址 VIP，则添加一个优先级 100 的流。对于 IPv4 VIP，流匹配 `reg9[6] == 0 && ct.new && ip && ip4.dst == VIP && P.dst == PORT`。对于 IPv6 VIP，流匹配 `ct.new && ip && ip6.dst == VIP && P && P.dst == PORT`。流的操作是 `commit_lb_aff(vip = VIP:PORT, backend = backend ip: backend port, proto = P, timeout = T);`。

*   添加一个优先级 0 的流，匹配所有数据包并应用操作 `next;`。

## 入口表 17: Pre-Hairpin

*   如果逻辑交换机配置了负载均衡器，则添加一个优先级 100 的流，匹配 `ip && ct.trk`，通过执行操作 `reg0[6] = chk_lb_hairpin();` 和 `reg0[12] = chk_lb_hairpin_reply();` 来检查数据包是否需要发夹（如果负载均衡后目标 IP 与源 IP 匹配），并推进数据包到下一个表。

*   一个优先级 0 的流，只是将流量移动到下一个表。

## 入口表 18: Nat-Hairpin

*   如果逻辑交换机配置了负载均衡器，则添加一个优先级 100 的流，匹配 `ip && ct.new && ct.trk && reg0[6] == 1`，通过执行操作 `ct_snat_to_vip` 将源 IP NAT 到负载均衡器 VIP 来对流量进行发夹，并推进数据包到下一个表。

*   如果逻辑交换机配置了负载均衡器，则添加一个优先级 100 的流，匹配 `ip && ct.est && ct.trk && reg0[6] == 1`，通过执行操作 `ct_snat` 将源 IP NAT 到负载均衡器 VIP 来对流量进行发夹，并推进数据包到下一个表。

*   如果逻辑交换机配置了负载均衡器，则添加一个优先级 90 的流，匹配 `ip && reg0[12] == 1`，匹配发夹流量的回复（即，目标 IP 是 VIP，源 IP 是后端 IP，对于 L4 负载均衡器，源 L4 端口是后端端口），并执行 `ct_snat` 并推进数据包到下一个表。

*   一个优先级 0 的流，只是将流量移动到下一个表。

## 入口表 19: Hairpin

*   如果逻辑交换机附加了 `vtep` 类型的逻辑交换机端口，则对于附加到此逻辑交换机且具有 chassis redirect 端口 cr-RP 的每个分布式网关路由器端口 RP，添加一个优先级 2000 的流，匹配 `reg0[14] == 1 && is_chassis_resident(cr-RP)`，操作为 `next;`。

    `reg0[14]` 寄存器位在入口 L2 端口安全检查表中为从 HW VTEP (ramp) 端口接收的流量设置。

*   如果逻辑交换机附加了 `vtep` 类型的逻辑交换机端口，则添加一个优先级 1000 的流，匹配从 HW VTEP (ramp) 端口接收的流量的 `reg0[14]` 寄存器位。此流量传递到入口表 `ls_in_l2_lkup`。

*   一个优先级 1 的流，对 Pre-Hairpin 表中非默认流匹配的流量进行发夹。发夹在 L2 完成，以太网地址交换，数据包在输入端口上环回。

*   一个优先级 0 的流，只是将流量移动到下一个表。

## 入口表 20: LB 后的 from-lport ACL 评估

此表中的逻辑流密切复制了 OVN_Northbound 数据库中 ACL 评估表中的流，用于 `from-lport` 方向，且 `apply-after-lb` 选项设置为 true。ACL 表中的优先级值范围有限，并增加了 1000，以便为更高和更低优先级的 OVN 默认流留出空间。此表中的流通过为允许类型的 ACL 设置 `reg8[16]`，为丢弃 ACL 设置 `reg8[17]`，为拒绝 ACL 设置 `reg8[17]` 来指示 ACL 结论，然后将数据包推进到下一个表。在本文档中，这些将被称为允许位、丢弃位和拒绝位。

与负载均衡器之前评估的 ACL 一样，如果 ACL 配置了层值，则除了 ACL 的匹配之外，还将 `reg8[30..31]` 中提供的当前层计数器与 ACL 配置的层进行匹配。

*   `allow` apply-after-lb ACL 转换为设置允许位的逻辑流。如果此数据路径上有任何有状态 ACL（包括 before-lb 和 after-lb ACL），则 `allow` ACL 也会运行 `ct_commit; next;`（这作为即将到来的表将连接提交到 conntrack 的提示）。如果 ACL 具有标签，则 `reg3` 加载标签值，并且 `reg0[13]` 位设置为 1（这作为下一个表将标签提交到 conntrack 的提示）。

*   `allow-related` apply-after-lb ACL 转换为设置允许位并运行 `ct_commit {ct_label=0/1; }; next;` 操作（对于新连接）和 `reg0[1] = 1; next;`（对于现有连接）的逻辑流。如果 ACL 具有标签，则 `reg3` 加载标签值，并且 `reg0[13]` 位设置为 1（这作为下一个表将标签提交到 conntrack 的提示）。

*   `allow-stateless` apply-after-lb ACL 转换为设置允许位并前进到下一个表的逻辑流。

*   `reject` apply-after-lb ACL 转换为设置拒绝位并前进到下一个表的逻辑流。

*   `pass` apply-after-lb ACL 转换为不设置允许、丢弃或拒绝位并前进到下一个表的逻辑流。

*   其他 apply-after-lb ACL 为新连接或未跟踪连接设置丢弃位，为已知连接设置 `ct_commit { ct_label=1/1; }`。设置 `ct_label` 将连接标记为先前已允许，但由于策略更改而不应再允许的连接。

*   一个优先级 65532 的流，匹配设置了 `reg0[17]` 的数据包（回复现有会话或与现有会话相关的流量），并通过设置允许位并前进到下一个表来允许这些数据包。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 21: LB 后的 from-lport ACL 采样

此表中的逻辑流对启用了采样的 `from-lport` ACL（LB 后评估）匹配的流量进行采样。

*   如果没有 ACL 启用采样，则安装一个优先级 0 的流，匹配所有内容并前进到下一个表。

*   对于配置了 `sample_new` 的每个 ACL，安装一个优先级 1100 的流，匹配保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。

*   对于配置了 `sample_est` 的每个 ACL，安装一个优先级 1200 的流，匹配原始方向上已建立流量的保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。

*   对于配置了 `sample_est` 的每个 ACL，安装一个优先级 1200 的流，匹配回复方向上已建立流量的保存的 `observation_point_id` 值。此流生成 `sample()` 操作，然后将数据包推进到下一个表。注意：此流安装在相反的管道中（对于在出口方向应用的 ACL 安装在入口管道中，对于在入口方向应用的 ACL 安装在出口管道中）。

## 入口表 22: LB 后的 from-lport ACL 操作

此表中的逻辑流根据前一个表中可能已设置的允许、丢弃和拒绝位的值决定如何继续。

*   如果未配置 ACL，则安装一个优先级 0 的流，匹配所有内容并前进到下一个表。

*   安装一个优先级 1000 的流，如果设置了允许位，则将数据包推进到下一个表。

*   安装一个优先级 1000 的流，如果设置了丢弃位，则运行 `drop;` 操作。

*   安装一个优先级 1000 的流，如果是 TCP 连接则运行 `tcp_reset { output <-> inport; next(pipeline=egress,table=5);}` 操作，如果是 UDP 连接则运行 `icmp4/icmp6` 操作，如果是 SCTP 关联则运行 `sctp_abort {output <-> inport; next(pipeline=egress,table=5);}` 操作。

*   如果有任何 ACL 配置了层，则安装三个优先级 500 的流。如果当前层计数器为 0、1 或 2，则当前层计数器加一，并将数据包送回上一个表进行重新评估。

## 入口表 23: Stateful

*   添加一个优先级 100 的流，该流将数据包提交到 conntrack，并根据先前表提供的提示（匹配 `reg0[1] == 1 && reg0[13] == 1`），用 `reg3` 值设置 `ct_label` 的最高 32 位。这由带标签的 ACL 用于将标签值提交到 conntrack。

*   对于没有标签的 ACL，第二个优先级 100 的流根据先前表提供的提示（匹配 `reg0[1] == 1 && reg0[13] == 0`），使用 `ct_commit; next;` 操作将数据包提交到连接跟踪器。

*   对应于上述两个优先级 100 的流，添加一个优先级 110 的流，它具有以下额外的匹配和操作，但其他方面与优先级 100 的流相同。匹配：`reg8[21] == 1`（数据包匹配设置了 `network_function_group` 的 ACL）。操作：`ct_label.nf_group = 1; ct_label.nf_group_id = reg0[22..29];` 这是为了将 `network_function` 信息提交到 conntrack，以便响应和相关数据包也可以重定向到它。

*   一个优先级 0 的流，只是将流量移动到下一个表。

## 入口表 25: Network Function

此表实现网络功能的数据包重定向规则。如果 `from-lport` ACL 中的 `network_function_group` 列设置为 `Network_Function_Group` 实体的 id，则入口 ACL 评估阶段将设置一组寄存器，如前所述。这些寄存器在这里使用。如果是 `to-lport` ACL，请求数据包将在出口管道中重定向，稍后将进行描述。响应在此处使用请求处理期间提交在 `ct_label` 中的 `network_function_group` id 进行处理。

一个组中可以有一个或多个网络功能。健康监控是通过发送 `Network_Function_Health_Check` 中定义的参数的数据路径探测来完成的。为每个 `network_function_group` 选择一个健康的网络功能。如果没有健康的，或者如果未配置健康监控，则从组中选择任何一个。此表中的规则将 `from-lport` ACL 的请求数据包和 `to-lport` ACL 的响应数据包重定向到所选网络功能的 inport。如果此逻辑交换机上不存在网络功能端口，则使用其子端口（如果有）。在下面的语句中，当提到网络功能端口时，它意味着适用于此逻辑交换机的父端口或子端口。

*   对于每个网络功能端口 P，添加一个优先级 100 的流，匹配 `inport == P` 并将数据包推进到下一个表。因此，来自网络功能的数据包不受重定向的影响。此流还设置 `reg5[16..31] = ct_label.tun_if_id`。这用于在 VLAN 子网的跨主机流量重定向的情况下将数据包隧道传输到发起主机。此 `ct_label` 字段存储此连接的发起主机的 openflow 隧道接口 id，并在出口 Stateful 表中填充。

*   对于每个 `network_function_group` id，一个优先级 99 的流匹配 `reg8[21] == 1 && reg8[22] == 1 && reg0[22..29] == id` 并设置 `outport=P; output;`，其中 P 是所选网络功能的 inport。这确保了匹配带有网络功能的 `from-lport` ACL 的流的请求数据包的重定向。

*   对于每个 `network_function_group` id，一个优先级 99 的规则匹配 `reg8[21] == 1 && reg8[22] == 0 && ct_label.nf_group_id == id` 并采取与上述相同的操作。这确保了匹配带有网络功能的 `to-lport` ACL 的响应和相关数据包的重定向。

*   在上述每种情况下，当相同的数据包未更改地通过网络功能的另一个端口出来时，它将匹配优先级 100 的流并转发到下一个表。

*   一个优先级 100 的规则，跳过命中了网络功能 ACL 的组播数据包的重定向。匹配 `8[21] == 1 && eth.mcast`，操作是前进到下一个表。

*   一个优先级 1 的规则，检查 `reg8[[21]] == 1`，并丢弃此类数据包。这是为了解决数据包命中了带有网络功能的 ACL，但网络功能在此逻辑交换机上没有端口或子端口的情况。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 25: ARP/ND 响应器

此表为已知 IP 实现逻辑交换机中的 ARP/ND 响应器。ARP 响应器流的优点是通过本地响应 ARP 请求来限制 ARP 广播，而无需发送到其他管理程序。一种常见情况是当 inport 是与 VIF 关联的逻辑端口时，广播在本地管理程序上响应，而不是在整个网络上广播并由目标 VM 响应。此行为是代理 ARP。

ARP 请求从类型为 default 的逻辑交换机 inport 的 VM 到达。对于这种情况，逻辑交换机代理 ARP 规则可以是针对其他 VM 或逻辑路由器端口。逻辑交换机代理 ARP 规则可以为其他逻辑交换机 VIF 端口（默认逻辑交换机端口类型，代表到 VM 或容器的连接）上的 IP 地址的 mac 绑定编程，也可以为逻辑交换机路由器类型端口（代表其逻辑路由器端口对等体）上的 IP 地址的 mac 绑定编程。为了支持逻辑路由器端口的代理 ARP，必须在逻辑交换机路由器类型端口上配置 IP 地址，该值与对等逻辑路由器端口的值相同。配置的 MAC 地址也必须匹配。当 VM 发送对分布式逻辑路由器端口的 ARP 请求时，如果附加逻辑交换机的对等路由器类型端口没有配置 IP 地址，则 ARP 请求将在逻辑交换机上广播。ARP 请求的副本之一将通过逻辑交换机路由器类型端口到达逻辑路由器数据路径，逻辑路由器 ARP 响应器将在那里生成回复。分布式逻辑路由器的 MAC 绑定一旦被关联的 VM 学习，就用于该 VM 需要路由的所有通信。因此，VM 重新 arp 逻辑路由器端口的 mac 绑定的操作应该很少见。

当在 L2 网关端口上外部接收 ARP 请求时，也可以命中逻辑交换机 ARP 响应器代理 ARP 规则。在这种情况下，充当 L2 网关的管理程序代表目标 VM 响应 ARP 请求。

请注意，从 localnet 逻辑 inport 接收的 ARP 请求可以直接转到 VM（在这种情况下 VM 响应），或者如果数据包用于解析逻辑路由器端口下一跳地址，则可以命中逻辑路由器端口的 ARP 响应器。在任何一种情况下，都不会命中逻辑交换机 ARP 响应器规则。它包含这些逻辑流：

*   如果数据包是从 HW VTEP (ramp switch) 接收的，并且此数据包是 ARP 或邻居请求，则此类数据包以最大优先级传递到下一个表。来自 HW VTEP 的 ARP/ND 请求必须在逻辑路由器入口管道中处理。

*   如果逻辑交换机没有配置了 `options:arp_proxy` 的路由器端口，则添加一个优先级 100 的流以跳过 ARP 响应器，如果 inport 类型为 `localnet`，则直接前进到下一个表。发送到 localnet 端口的 ARP 请求可以被多个管理程序接收。现在，因为相同的 mac 绑定规则下载到所有管理程序，所以多个管理程序中的每一个都会响应。这会混淆 ARP 请求源上的 L2 学习。在类型为 router 的 inport 上接收的 ARP 请求预计不会命中任何逻辑交换机 ARP 响应器流。但是，没有为这些数据包安装跳过流，因为这会有一些额外的流成本，而且价值似乎有限。

*   如果 inport V 是类型 `virtual`，则为 `options:virtual-parents` 列中配置的每个 P 添加一个优先级 100 的逻辑流，匹配 `inport == P && ((arp.op == 1 && arp.spa == VIP && arp.tpa == VIP) || (arp.op == 2 && arp.spa == VIP))` 或 `inport == P && ((nd_ns && ip6.dst == {VIP, NS_MULTICAST_ADDR} && nd.target == VIP) || (nd_na && nd.target == VIP))`，并应用操作 `bind_vport(V, inport);` 并前进到下一个表。其中 VIP 是在 `options:virtual-ip` 列中配置的虚拟 ip，`NS_MULTICAST_ADDR` 是对应于 VIP 的请求节点组播地址。

*   优先级 50 的流，仅匹配对每个逻辑交换机端口的每个已知 IPv4 地址 A 的广播 ARP 请求，并直接用相应的以太网地址 E 响应 ARP 回复：`eth.dst = eth.src; eth.src = E; arp.op = 2; /* ARP reply. */ arp.tha = arp.sha; arp.sha = E; arp.tpa = arp.spa; arp.spa = A; outport = inport; flags.loopback = 1; output;`。

    对于已关闭的逻辑端口（除非在北向数据库的 `NB_Global` 表的 `options` 列中将 `ignore_lsp_down` 配置为 true），类型为 `virtual` 的逻辑端口，设置了“unknown”地址的逻辑端口，配置了 `options:disable_arp_nd_rsp=true` 的逻辑端口，以及配置了 `other_config:vlan-passthru=true` 的逻辑交换机的逻辑端口，省略这些流。

    如果为 router 类型的逻辑交换机端口在 `Logical_Switch_Port` 表的 `options:arp_proxy` 列中定义了 IPv4 地址列表，则为该列表添加上述 ARP 响应器流。

*   优先级 50 的流，匹配对每个逻辑交换机端口（除 router 类型外）的每个已知 IP 地址 A（以及 A 的请求节点地址）的 IPv6 ND 邻居请求，并直接用相应的以太网地址 E 响应邻居通告。

    优先级 50 的流，匹配对 router 类型的逻辑交换机端口的每个已知 IP 地址 A（以及 A 的请求节点地址）的 IPv6 ND 邻居请求，并直接用相应的以太网地址 E 响应邻居通告。

    对于已关闭的逻辑端口（除非在北向数据库的 `NB_Global` 表的 `options` 列中将 `ignore_lsp_down` 配置为 true），类型为 `virtual` 的逻辑端口，以及设置了“unknown”地址的逻辑端口，省略这些流。

    如果为 router 类型的逻辑交换机端口在 `Logical_Switch_Port` 表的 `options:arp_proxy` 列中定义了 IPv6 地址列表，则为该列表添加上述 NDP 响应器流。

*   优先级 100 的流，其匹配条件类似于上面的 ARP 和 ND 流，除了它们仅匹配来自拥有相关 IP 地址的 inport 的数据包，操作为 `next;`。这些流防止 OVN 回复（例如）VM 发出的对其自身 IP 地址的 ARP 请求。VM 仅在尝试检测重复 IP 地址分配时发出此类请求，因此发送回复将阻止 VM 接受它拥有的 IP 地址。

*   对于 `Load_Balancer` 表的 `ip_port_mappings:ENDPOINT_IP` 列值中定义的每个 `SVC_MON_SRC_IP`，添加优先级 110 的逻辑流，匹配 `arp.tpa == SVC_MON_SRC_IP && arp.op == 1` 并应用 ARP 回复操作，其中 E 是 `NB_Global` 表中 `options:svc_monitor_mac` 列中定义的服务监视器源 mac。此 mac 用作负载均衡器端点 IP 健康检查的服务监视器数据包中的源 mac。`SVC_MON_SRC_IP` 用作负载均衡器端点 IP 健康检查的服务监视器 IPv4 数据包中的源 ip。如果发送了对 IP `SVC_MON_SRC_IP` 的 ARP 请求，则需要这些流。对于 IPv6，添加类似的流。

*   对于 `Forwarding_Group` 表中配置的每个 VIP，添加优先级 50 的逻辑流，匹配 `arp.tpa == vip && arp.op == 1` 并应用 ARP 回复操作，其中 E 是 `vmac` 中定义的转发组的 mac。A 用作负载均衡流量到子端口的目标 ip，或作为子端口后主机的下一跳。如果发送了对 IP vip 的 ARP 请求，则需要这些流来响应 ARP 请求。

*   一个优先级 0 的回退流，匹配所有数据包并前进到下一个表。

## 入口表 26: DHCP 选项处理

此表将 DHCPv4 选项添加到来自配置了 IPv4 地址和 DHCPv4 选项的逻辑端口的 DHCPv4 数据包，同样适用于 DHCPv6 选项。此表还为 external 类型的逻辑端口添加流。

*   为这些逻辑端口添加优先级 100 的逻辑流，匹配 `udp.src = 68` 和 `udp.dst = 67` 的 IPv4 数据包，应用操作 `put_dhcp_opts` 并将数据包推进到下一个表。对于 DHCPDISCOVER 和 DHCPREQUEST，这将数据包转换为 DHCP 回复，将 DHCP offer IP `ip` 和选项添加到数据包，并将 1 存储到 `reg0[3]` 中。对于其他类型的数据包，它只将 0 存储到 `reg0[3]` 中。无论哪种方式，它都会继续到下一个表。

*   为这些逻辑端口添加优先级 100 的逻辑流，匹配 `udp.src = 546` 和 `udp.dst = 547` 的 IPv6 数据包，应用操作 `put_dhcpv6_opts` 并将数据包推进到下一个表。对于 DHCPv6 Solicit/Request/Confirm 数据包，这将数据包转换为 DHCPv6 Advertise/Reply，将 DHCPv6 offer IP `ip` 和选项添加到数据包，并将 1 存储到 `reg0[3]` 中。对于其他类型的数据包，它只将 0 存储到 `reg0[3]` 中。无论哪种方式，它都会继续到下一个表。

*   一个优先级 0 的流，匹配所有数据包并前进到表 16。

## 入口表 27: DHCP 响应

此表为前一个表生成的 DHCP 回复实现 DHCP 响应器。

*   为配置了 DHCPv4 选项的逻辑端口添加优先级 100 的逻辑流，匹配 `udp.src == 68 && udp.dst == 67 && reg0[3] == 1` 的 IPv4 数据包，并在应用操作后响应回 inport。如果 `reg0[3]` 设置为 1，则表示操作 `put_dhcp_opts` 成功。

*   为配置了 DHCPv6 选项的逻辑端口添加优先级 100 的逻辑流，匹配 `udp.src == 546 && udp.dst == 547 && reg0[3] == 1` 的 IPv6 数据包，并在应用操作后响应回 inport。如果 `reg0[3]` 设置为 1，则表示操作 `put_dhcpv6_opts` 成功。

*   一个优先级 0 的流，匹配所有数据包并前进到表 17。

## 入口表 28 DNS 查找

此表查找并将 DNS 名称解析为相应的配置 IP 地址。

*   如果配置了 DNS 记录，则为每个逻辑交换机数据路径添加优先级 100 的逻辑流，匹配 `udp.dst = 53` 的 IPv4 和 IPv6 数据包，应用操作 `dns_lookup` 并将数据包推进到下一个表。对于有效的 DNS 数据包，如果可以解析 DNS 名称，则将数据包转换为 DNS 回复，并将 1 存储到 `reg0[4]` 中。对于失败的 DNS 解析或其他类型的数据包，它只将 0 存储到 `reg0[4]` 中。无论哪种方式，它都会继续到下一个表。

## 入口表 29 DNS 响应

此表为前一个表生成的 DNS 回复实现 DNS 响应器。

*   如果配置了 DNS 记录，则为每个逻辑交换机数据路径添加优先级 100 的逻辑流，匹配 `udp.dst = 53 && reg0[4] == 1` 的 IPv4 和 IPv6 数据包，并在应用操作后响应回 inport。如果 `reg0[4]` 设置为 1，则表示操作 `dns_lookup` 成功。

## 入口表 30 外部端口

来自外部逻辑端口的流量通过 localnet 端口进入入口数据路径管道。此表添加以下逻辑流来处理来自这些端口的流量。

*   为每个不驻留在 chassis 上的外部逻辑端口添加优先级 100 的流，以丢弃对路由器 IP（逻辑交换机的）的 ARP/IPv6 NS 请求，该请求匹配外部逻辑端口的 inport 和外部逻辑端口的有效 `eth.src` 地址。此流保证来自外部端口的对路由器 IP 地址的 ARP/NS 请求仅由声明了这些外部端口的 chassis 响应。所有其他 chassis 丢弃这些数据包。

    为每个不驻留在 chassis 上的外部逻辑端口添加优先级 100 的流，以丢弃任何发往路由器 mac 的数据包 - 匹配 `inport == external && eth.src == E && eth.dst == R && !is_chassis_resident("external")`，其中 E 是外部端口 mac，R 是路由器端口 mac。

*   一个优先级 0 的流，匹配所有数据包并前进到表 20。

## 入口表 31 目标查找

此表实现交换行为。它包含这些逻辑流：

*   一个优先级 110 的流，匹配 `eth.src == E`，适用于所有逻辑交换机数据路径，并应用操作 `handle_svc_check(inport)`。其中 E 是 `NB_Global` 表 `options:svc_monitor_mac` 列中定义的服务监视器 mac。

*   一个优先级 100 的流，如果逻辑交换机上启用了组播侦听，则将所有 IGMP/MLD 数据包发送到 `ovn-controller`。

*   一个优先级 100 的流，当逻辑交换机上启用了 DHCP 中继时，将来自 VIF 的所有 DHCP 广播数据包转发到逻辑路由器端口的 MAC。

*   一个优先级 100 的流，匹配 `reg8[23] == 1` 并执行 output 操作。这确保了从出口表 Network Function 注入回此表的数据包（在其设置了用于数据包重定向的 outport 之后）被转发而无需任何进一步处理。

*   对于定义为路由协议重定向目标的任何逻辑端口，我们重定向与 `routing-protocols` 选项中指定的协议相关的流量。

*   优先级 90 的流，用于中转交换机，将注册的 IP 组播流量转发到其相应的组播组。

*   优先级 90 的流，将注册的 IP 组播流量转发到其相应的组播组。流还将数据包转发到 `MC_MROUTER_FLOOD` 组播组。

*   一个优先级 85 的流，将所有发往 224.0.0.X 的 IP 组播流量转发到 `MC_FLOOD_L2` 组播组。

*   一个优先级 85 的流，将所有发往保留组播 IPv6 地址的 IP 组播流量转发到 `MC_FLOOD` 组播组。

*   一个优先级 80 的流，将所有未注册的 IP 组播流量转发到 `MC_STATIC` 组播组。

*   一个优先级 80 的流，如果启用了组播侦听且禁用了未注册组播泛洪，则丢弃所有未注册的 IP 组播流量。

*   优先级 80 的流，用于连接到交换机的路由器端口拥有的每个 IP 地址/VIP/NAT 地址。这些流匹配特定 IP 地址的 ARP 请求和 ND 数据包。匹配的数据包仅转发到拥有 IP 地址的路由器和 `MC_FLOOD_L2` 组播组。

*   优先级 75 的流，用于每个连接到逻辑路由器的端口，匹配自发起的 ARP 请求/RARP 请求/ND 数据包。这些数据包被泛洪到 `MC_FLOOD_L2`。

*   一个优先级 72 的流，如果 `other_config:broadcast-arps-to-all-routers=true`，则将所有带有以太网广播或组播 `eth.dst` 的 ARP 请求和 ND 数据包输出到 `MC_FLOOD_L2` 组播组。

*   一个优先级 70 的流，将所有带有以太网广播或组播 `eth.dst` 的数据包输出到 `MC_FLOOD` 组播组。

*   一个优先级 50 的流，将每个已知的以太网地址与 `eth.dst` 进行匹配。此流的操作将数据包输出到单个关联的输出端口（如果已启用）。如果 LSP 被禁用，则应用 `drop;` 操作。

*   一个优先级 0 的回退流，匹配所有数据包，操作为 `outport = get_fdb(eth.dst); next;`。

## 入口表 32 目标未知

此表处理未找到或在逻辑交换机数据路径的 MAC 学习表中查找过的目标的数据包。

*   为每个禁用的逻辑交换机端口 P 添加优先级 50 的流，匹配 `outport == P`。此流具有操作 `drop;`。

*   如果逻辑交换机具有设置了“unknown”地址的逻辑端口，则添加优先级 50 的流，匹配 `outport == "none"`，然后将其输出到 `MC_UNKNOWN` 组播组。

*   如果逻辑交换机没有设置“unknown”地址的逻辑端口，则添加优先级 50 的流，匹配 `outport == none` 并丢弃数据包。

*   一个优先级 0 的回退流，将数据包输出到出口阶段，outport 从 `get_fdb` 操作中学习。
