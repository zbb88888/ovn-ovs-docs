# 数据包的架构物理生命周期

本节描述数据包如何通过 OVN 从一个虚拟机或容器传输到另一个。此描述侧重于数据包的物理处理；有关数据包逻辑生命周期的描述，请参阅 `ovn-sb(5)` 中的 `Logical_Flow` 表。

为了清楚起见，本节提到了几个数据和元数据字段，在此总结如下：

*   `tunnel key` (隧道密钥)
    当 OVN 将数据包封装在 Geneve 或其他隧道中时，它会附加额外的数据，以允许接收 OVN 实例正确处理它。这取决于特定的封装采取不同的形式，但在每种情况下，我们在此都将其称为“隧道密钥”。有关详细信息，请参阅下面的“隧道封装”。

*   `logical datapath field` (逻辑数据路径字段)
    表示正在处理数据包的逻辑数据路径的字段。OVN 使用 OpenFlow 1.1+ 简单（且令人困惑地）称为“元数据”的字段来存储逻辑数据路径。（此字段作为隧道密钥的一部分跨隧道传递。）

*   `logical input port field` (逻辑输入端口字段)
    表示数据包进入逻辑数据路径的逻辑端口的字段。OVN 将此存储在 Open vSwitch 扩展寄存器号 14 中。

    Geneve 隧道将此字段作为隧道密钥的一部分传递。Ramp 交换机 VXLAN 隧道不显式携带逻辑输入端口，但由于它们用于与从 OVN 角度看仅包含单个逻辑端口的网关通信，因此 OVN 可以在进入 OVN 逻辑管道时将逻辑输入端口字段设置为此端口。对于常规 VXLAN 隧道，它们根本不携带输入端口字段。这对集群功能施加了额外的限制，这在“隧道封装”一节中进行了描述。

*   `logical output port field` (逻辑输出端口字段)
    表示数据包将离开逻辑数据路径的逻辑端口的字段。这在逻辑入口管道开始时初始化为 0。OVN 将此存储在 Open vSwitch 扩展寄存器号 15 中。

    Geneve 和常规 VXLAN 隧道将此字段作为隧道密钥的一部分传递。Ramp 交换机 VXLAN 隧道不传输逻辑输出端口字段，并且由于它们不在隧道密钥中携带逻辑输出端口字段，因此当 OVN 管理程序从 Ramp 交换机 VXLAN 隧道接收数据包时，数据包将重新提交到表 8 以确定输出端口；当数据包到达表 42 时，这些数据包将重新提交到表 43 进行本地传递，方法是检查 `MLF_RCV_FROM_RAMP` 标志，该标志在数据包从 Ramp 隧道到达时设置。

*   `conntrack zone field for logical ports` (逻辑端口的连接跟踪区域字段)
    表示逻辑端口的连接跟踪区域的字段。该值仅具有本地意义，在 Chassis 之间没有意义。这在逻辑入口管道开始时初始化为 0。OVN 将此存储在 Open vSwitch 扩展寄存器号 13 的低 16 位中。

*   `conntrack zone fields for routers` (路由器的连接跟踪区域字段)
    表示路由器的连接跟踪区域的字段。这些值仅具有本地意义，在 Chassis 之间没有意义。OVN 将南北向流量（用于 DNAT 或 ECMP 对称回复）的区域信息存储在 Open vSwitch 扩展寄存器号 11 中，将南向北流量（用于 SNAT）的区域信息存储在 Open vSwitch 扩展寄存器号 12 中。

*   `Encap ID for logical ports` (逻辑端口的封装 ID)
    记录 ID 的字段，该 ID 指示根据原始输入逻辑端口向远程 Chassis 发送数据包时应使用的封装 IP。这在有多个 IP 可用于封装时很有用。该值仅具有本地意义，在 Chassis 之间没有意义。这在逻辑入口管道开始时初始化为 0。OVN 将此存储在 Open vSwitch 扩展寄存器号 13 的高 16 位中。

*   `logical flow flags` (逻辑流标志)
    逻辑标志旨在处理表之间的上下文保持，以便决定匹配后续表中的哪些规则。这些值仅具有本地意义，在 Chassis 之间没有意义。OVN 将逻辑标志存储在 Open vSwitch 扩展寄存器号 10 中。

*   `VLAN ID`
    VLAN ID 用作 OVN 与嵌套在 VM 内的容器之间的接口（有关更多信息，请参阅上面的“VM 内容器接口的生命周期”）。

最初，入口管理程序上的 VM 或容器在连接到 OVN 集成网桥的端口上发送数据包。然后：

1.  OpenFlow 表 0 执行物理到逻辑的转换。它匹配数据包的入口端口。其操作通过将逻辑数据路径字段设置为标识数据包正在遍历的逻辑数据路径，并将逻辑输入端口字段设置为标识入口端口，从而用逻辑元数据注释数据包。然后它重新提交到表 8 以进入逻辑入口管道。

    源自嵌套在 VM 内的容器的数据包的处理方式略有不同。可以根据特定于 VIF 的 VLAN ID 区分原始容器，因此物理到逻辑转换流还匹配 VLAN ID，并且操作会剥离 VLAN 头。在此步骤之后，OVN 就像对待任何其他数据包一样对待来自容器的数据包。

    表 0 还处理来自其他 Chassis 的数据包。它通过入口端口（这是一个隧道）将它们与其他数据包区分开来。与刚进入 OVN 管道的数据包一样，操作用逻辑数据路径元数据注释这些数据包。对于支持它的隧道类型，它们还用逻辑输入端口元数据进行注释。此外，操作设置逻辑输出端口字段，这是可用的，因为在 OVN 中，隧道发生在已知逻辑输出端口之后。这些信息是从隧道封装元数据中获得的（有关编码详细信息，请参阅“隧道封装”）。然后操作重新提交到表 45 以进入逻辑出口管道。

2.  OpenFlow 表 8 到 39 执行 OVN 南向数据库中 `Logical_Flow` 表的逻辑入口管道。这些表完全用逻辑概念（如逻辑端口和逻辑数据路径）表示。`ovn-controller` 工作的一大部分是将它们转换为等效的 OpenFlow（特别是它转换表号：`Logical_Flow` 表 0 到 29 变为 OpenFlow 表 8 到 39）。

    每个逻辑流映射到一个或多个 OpenFlow 流。实际数据包通常只匹配其中一个，尽管在某些情况下它可能匹配多个流（这不成问题，因为它们都具有相同的操作）。`ovn-controller` 使用逻辑流 UUID 的前 32 位作为其 OpenFlow 流或流的 cookie。（这不一定是唯一的，因为逻辑流 UUID 的前 32 位不一定是唯一的。）

    某些逻辑流可以映射到 Open vSwitch “连接匹配”扩展（请参阅 `ovs-fields(7)`）。具有连接操作的流使用 0 的 OpenFlow cookie，因为它们可以对应于多个逻辑流。连接匹配的 OpenFlow 流包括对 `conj_id` 的匹配。

    如果某些逻辑流无法在给定的管理程序上使用，则可能不会在该管理程序的 OpenFlow 表中表示。例如，如果逻辑交换机中没有 VIF 驻留在给定的管理程序上，并且该逻辑交换机在该管理程序上不可达（例如，通过从该管理程序上的 VIF 开始的逻辑交换机和路由器的一系列跳跃），则该逻辑流可能不会在那里表示。

    大多数 OVN 操作在 OpenFlow（带有 OVS 扩展）中都有相当明显的实现，例如 `next;` 实现为 `resubmit`，`field = constant;` 实现为 `set_field`。有一些值得更详细地描述：

    *   `output:`
        通过将数据包重新提交到表 40 来实现。如果管道执行多个输出操作，则每个操作分别重新提交到表 40。这可用于将数据包的多个副本发送到多个端口。（如果数据包在输出操作之间未被修改，并且某些副本发往同一管理程序，则使用逻辑组播输出端口将节省管理程序之间的带宽。）

    *   `get_arp(P, A);`
    *   `get_nd(P, A);`
        通过将参数存储到 OpenFlow 字段中，然后重新提交到表 66 来实现，`ovn-controller` 使用从 OVN 南向数据库中的 `MAC_Binding` 表生成的流填充表 66。如果在表 66 中有匹配项，则其操作将绑定的 MAC 存储在以太网目标地址字段中。

        （OpenFlow 操作保存并恢复用于参数的 OpenFlow 字段，以便 OVN 操作不必知道这种临时使用。）

    *   `put_arp(P, A, E);`
    *   `put_nd(P, A, E);`
        通过将参数存储到 OpenFlow 字段中，然后将数据包输出到 `ovn-controller` 来实现，后者更新 `MAC_Binding` 表。

        （OpenFlow 操作保存并恢复用于参数的 OpenFlow 字段，以便 OVN 操作不必知道这种临时使用。）

    *   `R = lookup_arp(P, A, M);`
    *   `R = lookup_nd(P, A, M);`
        通过将参数存储到 OpenFlow 字段中，然后重新提交到表 67 来实现，`ovn-controller` 使用从 OVN 南向数据库中的 `MAC_Binding` 表生成的流填充表 67。如果在表 67 中有匹配项，则其操作设置逻辑流标志 `MLF_LOOKUP_MAC`。

        （OpenFlow 操作保存并恢复用于参数的 OpenFlow 字段，以便 OVN 操作不必知道这种临时使用。）

3.  OpenFlow 表 40 到 44 实现逻辑入口管道中的输出操作。具体来说，表 40 用作出口管道的入口点。表 40 检测对于相应接口来说太大的 IP 数据包。表 41 产生 ICMPv4 需要分片（或 ICMPv6 太大）错误，并将它们传递回违规端口。表 42 处理发往远程管理程序的数据包，表 43 处理发往本地管理程序的数据包，表 44 检查是否应丢弃逻辑输入和输出端口相同的数据包。

    逻辑补丁端口是一个特例。逻辑补丁端口没有物理位置，实际上驻留在每个管理程序上。因此，用于输出到本地管理程序上的端口的流表 43 自然也实现了到单播逻辑补丁端口的输出。但是，将相同的逻辑应用于属于逻辑组播组一部分的逻辑补丁端口会导致数据包重复，因为包含组播组中逻辑端口的每个管理程序也会将数据包输出到逻辑补丁端口。因此，组播组在表 42 中实现到逻辑补丁端口的输出。

    表 42 中的每个流匹配包含远程管理程序上逻辑端口的单播或组播逻辑端口的逻辑输出端口。每个流的操作实现将数据包发送到它匹配的端口。对于远程管理程序上的单播逻辑输出端口，操作将隧道密钥设置为正确的值，然后在隧道端口上将数据包发送到正确的管理程序。（当远程管理程序接收数据包时，那里的表 0 将将其识别为隧道数据包并将其传递给表 43。）对于组播逻辑输出端口，操作将数据包的一个副本发送到每个远程管理程序，方式与单播目标相同。如果组播组包含本地管理程序上的逻辑端口，则其操作也会重新提交到表 43。表 42 还包括：

    *   一个优先级较高的规则，用于匹配从 Ramp 交换机隧道接收的数据包（基于标志 `MLF_RCV_FROM_RAMP`），并将这些数据包重新提交到表 43 进行本地传递。从 Ramp 交换机隧道接收的数据包到达这里是因为隧道密钥中缺少逻辑输出端口字段，因此这些数据包需要提交到表 8 以确定输出端口。

    *   一个优先级较高的规则，用于根据逻辑输入端口匹配从类型为 `localport` 的端口接收的数据包，并将这些数据包重新提交到表 43 进行本地传递。类型为 `localport` 的端口存在于每个管理程序上，根据定义，它们的流量永远不应通过隧道流出。

    *   一个优先级较高的规则，用于匹配设置了 `MLF_LOCAL_ONLY` 逻辑流标志且目标是组播地址的数据包。此标志指示数据包不应传递到远程管理程序，即使组播目标包含远程管理程序上的端口。当 `ovn-controller` 是组播数据包的发起者时使用此标志。由于每个 `ovn-controller` 实例都在发起这些数据包，因此数据包只需要传递到本地端口。

    *   一个回退流，如果没有其他匹配项，则重新提交到表 43。

    表 43 中的流类似于表 42 中的流，但针对的是驻留在本地而不是远程的逻辑端口。对于本地管理程序上的单播逻辑输出端口，操作只是重新提交到表 44。对于包含一个或多个本地管理程序上的逻辑端口的组播输出端口，对于每个这样的逻辑端口 P，操作将逻辑输出端口更改为 P，然后重新提交到表 44。

    一个特殊情况是，当数据路径上存在 `localnet` 端口时，通过切换到 `localnet` 端口来连接远程端口。在这种情况下，不是在表 42 中添加流来到达远程端口，而是在表 43 中添加流以将逻辑输出端口切换到 `localnet` 端口，并重新提交到表 43，就像它是单播到本地管理程序上的逻辑端口一样。

    表 44 匹配并丢弃逻辑输入和输出端口相同且未设置 `MLF_ALLOW_LOOPBACK` 标志的数据包。它还丢弃指向 `localnet` 端口的 `MLF_LOCAL_ONLY` 数据包，前提是它们不是从网关或分布式路由器发送的 RA（通过位标志 `MLF_OVERRIDE_LOCAL_ONLY` 的存在进行检查）。它将其他数据包重新提交到表 46。

4.  OpenFlow 表 45 到 62 执行 OVN 南向数据库中 `Logical_Flow` 表的逻辑出口管道。出口管道可以在数据包传递之前执行最后阶段的验证。最终，它可能会执行输出操作，`ovn-controller` 通过重新提交到表 64 来实现该操作。管道从未执行输出的数据包实际上被丢弃（尽管它可能已经通过隧道穿过物理网络传输）。

    出口管道不能更改逻辑输出端口或导致进一步的隧道传输。

5.  当设置了 `MLF_ALLOW_LOOPBACK` 时，表 64 绕过 OpenFlow 环回。逻辑环回在表 44 中处理，但 OpenFlow 默认也会阻止到 OpenFlow 入口端口的环回。因此，当设置了 `MLF_ALLOW_LOOPBACK` 时，OpenFlow 表 64 保存 OpenFlow 入口端口，将其设置为零，重新提交到表 65 进行逻辑到物理的转换，然后恢复 OpenFlow 入口端口，从而有效地禁用 OpenFlow 环回预防。当未设置 `MLF_ALLOW_LOOPBACK` 时，表 64 流只是重新提交到表 65。

6.  OpenFlow 表 65 执行逻辑到物理的转换，与表 0 相反。它匹配数据包的逻辑出口端口。其操作将数据包输出到连接到代表该逻辑端口的 OVN 集成网桥的端口。如果逻辑出口端口是嵌套在 VM 中的容器，则在发送数据包之前，操作会推入带有适当 VLAN ID 的 VLAN 头。
